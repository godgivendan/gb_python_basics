# 1. Реализовать класс Matrix (матрица).
# Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
#
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
#
# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8
#
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__()
# для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
#
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы
# складываем с первым элементом первой строки второй матрицы и т.д.
print("================ 1 ================")


class Matrix:
    """Matrix"""
    __data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

    def __init__(self, data):
        if not isinstance(data, list):
            raise Exception("Данные должны быть переданы списком в формате [[1, 2, 3], [4, 5, 6], [7, 8, 9]]!")
        for dt in data:
            if not isinstance(data, list):
                raise Exception("Данные должны быть переданы списком в формате [[1, 2, 3], [4, 5, 6], [7, 8, 9]]!")
            else:
                for d in dt:
                    if not isinstance(d, int) and not isinstance(d, float):
                        raise Exception(
                            "Данные должны быть переданы списком в формате [[1, 2, 3], [4, 5, 6], [7, 8, 9]]! "+
                            "Числа в списках должны быть форматов int или float!")
        self.__data = data

    def __add__(self, other):
        # new_matrix = []
        # for i in range(0, len(self.__data)):
        #     new_matrix.append([self.__data[i][j] + other.__data[i][j] for j in range(0, len(self.__data[i]))])
        return Matrix([
            [self.__data[i][j] + other.__data[i][j] for j in range(0, len(self.__data[i]))]
            for i in range(0, len(self.__data))
        ])

    def __str__(self):
        s = ""
        for dt in self.__data:
            for d in dt:
                s += f" {d:>3} "
            s += "\n"
        return s


m1 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(m1)
m2 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(m2)
m3 = m1 + m2
print(m3)

m4 = Matrix([[1, 2, 3], [4, 5, 6]])
print(m4)
m5 = Matrix([[1, 2], [3, 4], [5, 6], [7, 8]])
print(m5)


# 2. Реализовать проект расчёта суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название.
# К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры:
# размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5),
# для костюма (2*H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.
print("================ 2 ================")


class Wear:
    """Wear"""
    name = ""

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f"{self.__doc__} {self.name}"


class Coat(Wear):
    """Coat"""
    v = 0

    def __init__(self, name, v):
        super().__init__(name)
        self.v = v

    @property
    def size(self):
        return self.v

    @size.setter
    def size(self, size):
        self.v = size

    def calculate(self):
        return self.v / 0.6 + 0.5

    def __str__(self):
        return f"{self.__doc__} - {self.name} {self.v}"


class Suit(Wear):
    """Suit"""
    h = 0

    def __init__(self, name, h):
        super().__init__(name)
        self.h = h

    @property
    def size(self):
        return self.h

    @size.setter
    def size(self, size):
        self.h = size

    def calculate(self):
        return 2 * self.h + 0.3

    def __str__(self):
        return f"{self.__doc__} - {self.name} {self.h}"


c1 = Coat("Palto1", 100)
print(c1)
print(c1.size)
print(f"Расход материала для {c1}: {c1.calculate()}")
c1.size = 11
print(c1.size)
print(f"Расход материала для {c1}: {c1.calculate()}")
print("")
s1 = Suit("Kostyum1", 56)
print(s1)
print(s1.size)
print(f"Расход материала для {s1}: {s1.calculate()}")
s1.size = 58
print(s1.size)
print(f"Расход материала для {s1}: {s1.calculate()}")
print("")

# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (__add__()),
# вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение
# и целочисленное (с округлением до целого) деление клеток, соответственно.
#
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух
# клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток
# больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек
# этих двух клеток.
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order()
# вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку:
# *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.
print("================ 3 ================")


class OrganicCell:
    """Органическая клетка"""
    cell_count = 0

    def __init__(self, cell_count: int):
        self.cell_count = abs(cell_count)

    def __add__(self, other):
        """
        Сложение.
        Объединение двух клеток.
        При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
        """
        return OrganicCell(self.cell_count + other.cell_count)

    def __sub__(self, other):
        """
        Вычитание.
        Участвуют две клетки.
        Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля,
        иначе выводить соответствующее сообщение.
        """
        sb = self.cell_count - other.cell_count
        if sb <= 0:
            raise Exception("Разность количества ячеек двух клеток должна быть больше нуля!")
        return OrganicCell(self.cell_count - other.cell_count)

    def __mul__(self, other):
        """
        Умножение.
        Создаётся общая клетка из двух.
        Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
        """
        return OrganicCell(self.cell_count * other.cell_count)

    def __truediv__(self, other):
        """
        Деление.
        Создаётся общая клетка из двух.
        Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
        """
        return OrganicCell(self.cell_count // other.cell_count)

    def make_order(self, row_cell_count):
        """
        Данный метод позволяет организовать ячейки по рядам.
        Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному
        аргументу.
        Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
        """
        return "\n".join(
            [
                '*'*(row_cell_count if self.cell_count - n > row_cell_count else self.cell_count-n)
                for n in range(0, self.cell_count, row_cell_count)
            ]
        )

    def __str__(self):
        return str(self.cell_count)


print("=============13x4")
oc1 = OrganicCell(13)
print(oc1.make_order(4))
print("=============7x10")
oc2 = OrganicCell(7)
print(oc2.make_order(10))
print("=============3x2")
oc3 = OrganicCell(3)
print(oc3.make_order(2))
print("=============4x4")
oc4 = OrganicCell(4)
print(oc4.make_order(4))
print("=============2x4")
oc5 = OrganicCell(2)
print(oc5.make_order(4))
print("=============+*/-")
oc6=((oc1+oc2)*oc3/oc4)-oc5
print(f"(({oc1} + {oc2}) * {oc3} / {oc4}) - {oc5} = {oc6}")
print(oc6.make_order(5))
